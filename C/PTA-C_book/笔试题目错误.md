在嵌套使用if语句时，C语言规定else总是( )。

A．和之前与其具有相同缩进位置的if配对
B．和之前与其最近的if配对
**C．和之前与其最近的且不带else的if配对**
D．和之前的第一个if配对

![image-20200412201535566](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200412201535566.png)



**while** (!x&&!y)中的循环条件表达式等价于:





**for**(表达式1;;表达式3)可理解为_______.



4-14

以下正确的函数定义形式是 ()。

 **A．double fun(int x, int y)** 

 B．double fun(int x ; int y) 

C．double fun(int x, int y); 

D．double fun(int x, y) 



以下不正确的说法是
A.实参可以是常量、变量或表达

B.实参可以是任何类型式

**C.形参可以是常量、变量或表达式**

D.形参应与对应的实参类型一致

**形参不能是常量**

<img src="../形参和实参.png" style="zoom: 33%;" />





以下正确的说法是
A.实参与其对应的形参共同占用一个存储单元
**B.实参与其对应的形参各占用独立的存储单元**
C.只有当实参与其对应的形参同名时才占用一个共同的存储单元
D.形参是虚拟的，不占用内存单元



逻辑表达式 x && 1 等价于关系表达式 **x!=0** 。(!错误:x==1)



![image-20200414110743663](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414110743663.png)

![image-20200414110831776](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414110831776.png)



![image-20200414110752690](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414110752690.png)



以下选项中，对基本类型相同的指针变量不能进行运算的运算符是   。 

**A．+** 

B．-

C．=

D．== 



若有以下说明，且 0<=i<10，则对**数组元素的错误引用**是  。

 int a[] = {0,1,2,3,4,5,6,7,8,9}, *p = a,i; 

*A．*\*(a+i) 

B．a[p-a+i]   //等价于a[i]

**C．p+i**

D．*(&a[i]) 



4．下列程序的输出结果是 。

 int main(void) { int a[10] = {0,1,2,3,4,5,6,7,8,9}, *p = a+3; printf(“%d”, *++p); return 0; } 

A．3 

**B．4**

C．a[4]的地址

D．非法

*p=a+3 等价于 a[3];  a[3]=3;



![image-20200414115135360](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414115135360.png)



![image-20200414115201690](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414115201690.png)



对于以下结构定义，(*p)->str++中的++加在  。

 struct { int len; char *str; } *p;

A．指针 str 上

B．指针 p 上

C．str 指向的内容上

**D．语法错误**



“.”称为 **成员（分量）** 运算符

“->”称为 **指向** 运算符

*称为**指针**运算符，是一个一元运算符，表示指针所指向的对象的值；
&称为**取地址**运算符，也是一个一元操作符，是用来得到一个对象的地址。



执行下列程序：

 #define MA(x, y) ( x*y ) 

i = 5;

 i = MA(i, i + 1) – 7; 

后变量 i 的值应为 

 A．30 

**B．19**

C．23 

D．1 



定义带参数的宏

#define JH(a,b,t) t = a; a = b; b = t

对两个参数 a、b 的值进行交换，下列表述中哪个是正确的  

A．不定义参数 a 和 b 将导致编译错误

B．不定义参数 a、b、t 将导致编译错误

**C．不定义参数 t 将导致运行错误**

D．不需要定义参数 a、b、t 类型

![image-20200414150012121](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414150012121.png)

下面说法中正确的是  

**A．若全局变量仅在单个 C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度** 

**B．若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度**

C．设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题

D．静态全局变量使用过多，可那会导致动态存储区（堆栈）溢出



![image-20200414152953375](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414152953375.png)

![image-20200414153003388](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414153003388.png)

C语言提供了多种预处理功能，如**宏定义、文件包含、条件编译**等