在嵌套使用if语句时，C语言规定else总是( )。

A．和之前与其具有相同缩进位置的if配对
B．和之前与其最近的if配对
**C．和之前与其最近的且不带else的if配对**
D．和之前的第一个if配对

![image-20200412201535566](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200412201535566.png)



**while** (!x&&!y)中的循环条件表达式等价于:





**for**(表达式1;;表达式3)可理解为_______.



4-14

以下正确的函数定义形式是 ()。

 **A．double fun(int x, int y)** 

 B．double fun(int x ; int y) 

C．double fun(int x, int y); 

D．double fun(int x, y) 



以下不正确的说法是
A.实参可以是常量、变量或表达

B.实参可以是任何类型式

**C.形参可以是常量、变量或表达式**

D.形参应与对应的实参类型一致

**形参不能是常量**

<img src="../形参和实参.png" style="zoom: 33%;" />





以下正确的说法是
A.实参与其对应的形参共同占用一个存储单元
**B.实参与其对应的形参各占用独立的存储单元**
C.只有当实参与其对应的形参同名时才占用一个共同的存储单元
D.形参是虚拟的，不占用内存单元



逻辑表达式 x && 1 等价于关系表达式 **x!=0** 。(!错误:x==1)



![image-20200414110743663](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414110743663.png)

![image-20200414110831776](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414110831776.png)



![image-20200414110752690](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414110752690.png)



以下选项中，对基本类型相同的指针变量不能进行运算的运算符是   。 

**A．+** 

B．-

C．=

D．== 



若有以下说明，且 0<=i<10，则对**数组元素的错误引用**是  。

 int a[] = {0,1,2,3,4,5,6,7,8,9}, *p = a,i; 

*A．*\*(a+i) 

B．a[p-a+i]   //等价于a[i]

**C．p+i**

D．*(&a[i]) 



4．下列程序的输出结果是 。

 int main(void) { int a[10] = {0,1,2,3,4,5,6,7,8,9}, *p = a+3; printf(“%d”, *++p); return 0; } 

A．3 

**B．4**

C．a[4]的地址

D．非法

*p=a+3 等价于 a[3];  a[3]=3;



![image-20200414115135360](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414115135360.png)



![image-20200414115201690](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414115201690.png)



对于以下结构定义，(*p)->str++中的++加在  。

 struct { int len; char *str; } *p;

A．指针 str 上

B．指针 p 上

C．str 指向的内容上

**D．语法错误**



“.”称为 **成员（分量）** 运算符

“->”称为 **指向** 运算符

*称为**指针**运算符，是一个一元运算符，表示指针所指向的对象的值；
&称为**取地址**运算符，也是一个一元操作符，是用来得到一个对象的地址。



执行下列程序：

 #define MA(x, y) ( x*y ) 

i = 5;

 i = MA(i, i + 1) – 7; 

后变量 i 的值应为 

 A．30 

**B．19**

C．23 

D．1 



定义带参数的宏

#define JH(a,b,t) t = a; a = b; b = t

对两个参数 a、b 的值进行交换，下列表述中哪个是正确的  

A．不定义参数 a 和 b 将导致编译错误

B．不定义参数 a、b、t 将导致编译错误

**C．不定义参数 t 将导致运行错误**

D．不需要定义参数 a、b、t 类型

![image-20200414150012121](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414150012121.png)

下面说法中正确的是  

**A．若全局变量仅在单个 C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度** 

**B．若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度**

C．设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题

D．静态全局变量使用过多，可那会导致动态存储区（堆栈）溢出



![image-20200414152953375](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414152953375.png)

![image-20200414153003388](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200414153003388.png)

C语言提供了多种预处理功能，如**宏定义、文件包含、条件编译**等

**4-18**

若 a、b 都是 int 类型变量， ______不是正确的赋值语句。
**A．a=b=60**
B．a=3.0
C．a=1,3
D．b=0;

C99才行



若 k 是基本整型变量，则以下程序段的输出是_____。

 k=8567; printf("|%-6d|\n",k); 

A．输出格式描述符不正确

B．输出为|008567|

**C．输出为|8567 |**

D． 输出为|-08567|



调用字符函数时，要求在源文件中包下以下命令行：

**\#include <ctype.h>**

调用**字符串**函数时，要求在源文件中包下以下命令行：

**\#include <string.h>**





C 语言源程序文件经过 C 语言编译程序编译之后生成一个后缀为**.obj**的文件

常数的书写格式决定了常数的类型和值，**10L** 是。 

A．基本整型常数 

B．短整型常数 

**C．长整型常数** 

D．无符号型常数



![image-20200418154523077](../../../../Users/SST/AppData/Roaming/Typora/typora-user-images/image-20200418154523077.png)

 表达式 ( (4|1)&3  ) 的值为**1** 。

 表达式 (~3&7 ) 的值为**4**。

 表达式 (~7&4 ) 的值为**0**。



下列程序段的输出结果是**2**。 

int *p, *q, k = 1, j=0 ; *

*p=&j; q = &k ; p = q ; (*p)++; 

printf("%d",*q); 

下列程序段的输出结果是**6**。

int *p, k = 5 ;

 \*p = &k ; ++(*p); 

printf("%d",k);



若 x 是单精度实型变量，表达式 (x = 10/4) 的值是 **2.0**

sizeof("key")==4(包含'\0')



C语言度中%3d  表示以3位的固定宽度输出整型数。

注意：不足知3位，道在前面补空格； 超过3位，**按实际位数**输出回（但是要在其范围内-32768 ~ 32767）。

```c
printf("%3d\n", 3);		// 输出_ _ 3  (其中 _ 表示空格)
printf("%3d\n", 312);	// 输出312 
printf("%3d\n", 3122);	// 输出3122
printf("%-3d\n", 3);	// 输出3 _ _
```

[二维数组指针引用]: http://c.biancheng.net/view/227.html

```c
int (*p)[N] = a;   
/*其中N是二维数组a[M][N]的列数, 是一个数字,  数组长度不能定义成变量*/
p[1][N-1] = size;
//这样赋值也是可以的  

*(p+i) == a[i];//等式两边作“*”运算得
*(p+i) + j == &a[i][j];//等式两边同时加上j行
```

 异或

```C
1^0=1;
1^1=0;
0^0=0;
3^6=5;//011^110->101
```

